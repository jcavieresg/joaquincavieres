source("update_dates.R")
library(MASS)
library(plotly)
library(fields)
# Set up a grid
n <- 30
x <- seq(0, 1, length.out = n)
y <- seq(0, 1, length.out = n)
grid <- expand.grid(x = x, y = y)
# Compute distance matrix
dists <- rdist(grid, grid)
# Define covariance function (exponential kernel)
sigma2 <- 1       # variance
range <- 0.2      # correlation range
cov_matrix <- sigma2 * exp(-dists / range)
# Simulate a Gaussian random field
set.seed(123)
z <- mvrnorm(1, mu = rep(0, nrow(grid)), Sigma = cov_matrix)
# Reshape for plotting
z_matrix <- matrix(z, nrow = n, byrow = TRUE)
# 3D Surface Plot using plotly
plot_ly(
x = x,
y = y,
z = ~z_matrix,
type = "surface",
colorscale = "Viridis"
) %>%
layout(
title = "Simulated Gaussian Random Field",
scene = list(
xaxis = list(title = "X"),
yaxis = list(title = "Y"),
zaxis = list(title = "Z")
)
library(MASS)
library(fields)
library(plot3D)
# Create grid
n <- 50
x <- seq(0, 1, length.out = n)
y <- seq(0, 1, length.out = n)
grid <- expand.grid(x = x, y = y)
# Compute distance matrix
d <- rdist(grid, grid)
# Exponential covariance
sigma2 <- 1
range <- 0.2
cov_mat <- sigma2 * exp(-d / range)
# Simulate field
set.seed(42)
z <- mvrnorm(1, mu = rep(0, nrow(grid)), Sigma = cov_mat)
sim1 <- grf(100, cov.pars = c(1, .25))
library(geoR)
sim1 <- grf(100, cov.pars = c(1, .25))
# a display of simulated locations and values
points(sim1)
# empirical and theoretical variograms
plot(sim1)
## alternative way
plot(variog(sim1, max.dist=1))
lines.variomodel(sim1)
#
# a "smallish" simulation
sim2 <- grf(441, grid = "reg", cov.pars = c(1, .25))
image(sim2)
## alternative way
plot(variog(sim1, max.dist=1))
lines.variomodel(sim1)
#
# a "smallish" simulation
sim2 <- grf(441, grid = "reg", cov.pars = c(1, .25))
image(sim2)
##
## 1-D simulations using the same seed and different noise/signal ratios
##
set.seed(234)
sim11 <- grf(100, ny=1, cov.pars=c(1, 0.25), nug=0)
set.seed(234)
sim12 <- grf(100, ny=1, cov.pars=c(0.75, 0.25), nug=0.25)
set.seed(234)
sim13 <- grf(100, ny=1, cov.pars=c(0.5, 0.25), nug=0.5)
##
par.ori <- par(no.readonly = TRUE)
par(mfrow=c(3,1), mar=c(3,3,.5,.5))
yl <- range(c(sim11$data, sim12$data, sim13$data))
image(sim11, type="l", ylim=yl)
image(sim12, type="l", ylim=yl)
image(sim13, type="l", ylim=yl)
par(par.ori)
## simulating within borders
data(parana)
pr1 <- grf(100, cov.pars=c(200, 40), borders=parana$borders, mean=500)
points(pr1)
pr1 <- grf(100, grid="reg", cov.pars=c(200, 40), borders=parana$borders)
points(pr1)
pr1 <- grf(100, grid="reg", nx=10, ny=5, cov.pars=c(200, 40), borders=parana$borders)
points(pr1)
# Create grid
n <- 10
x <- seq(0, 1, length.out = n)
y <- seq(0, 1, length.out = n)
grid <- expand.grid(x = x, y = y)
# Compute distance matrix
d <- rdist(grid, grid)
# Exponential covariance
sigma2 <- 1
range <- 0.2
cov_mat <- sigma2 * exp(-d / range)
# Simulate field
set.seed(42)
z <- mvrnorm(1, mu = rep(0, nrow(grid)), Sigma = cov_mat)
# Reshape to matrix
z_mat <- matrix(z, nrow = n)
# Plot with plot3D
persp3D(
x = x, y = y, z = z_mat,
colvar = z_mat,
col = terrain.colors(100),
theta = 45, phi = 25,
expand = 0.5,
shade = 0.6,
ticktype = "detailed",
xlab = "X", ylab = "Y", zlab = "Z",
main = "Static 3D Gaussian Random Field"
)
# Create grid
n <- 20
x <- seq(0, 1, length.out = n)
y <- seq(0, 1, length.out = n)
grid <- expand.grid(x = x, y = y)
# Compute distance matrix
d <- rdist(grid, grid)
# Exponential covariance
sigma2 <- 1
range <- 0.2
cov_mat <- sigma2 * exp(-d / range)
# Simulate field
set.seed(42)
z <- mvrnorm(1, mu = rep(0, nrow(grid)), Sigma = cov_mat)
# Reshape to matrix
z_mat <- matrix(z, nrow = n)
# Plot with plot3D
persp3D(
x = x, y = y, z = z_mat,
colvar = z_mat,
col = terrain.colors(100),
theta = 45, phi = 25,
expand = 0.5,
shade = 0.6,
ticktype = "detailed",
xlab = "X", ylab = "Y", zlab = "Z",
main = "Static 3D Gaussian Random Field"
)
library(MASS)
library(fields)
library(akima)
library(MASS)
library(fields)
library(akima)
install.packages("akima")
library(MASS)
library(fields)
library(akima)
library(plot3D)
# Set up coarse grid
n <- 25
x <- seq(0, 1, length.out = n)
y <- seq(0, 1, length.out = n)
grid <- expand.grid(x = x, y = y)
# Distance matrix
d <- rdist(grid, grid)
# Exponential covariance
sigma2 <- 1
range <- 0.2
cov_mat <- sigma2 * exp(-d / range)
# Simulate field
set.seed(123)
z <- mvrnorm(1, mu = rep(0, nrow(grid)), Sigma = cov_mat)
# Interpolate to a fine grid (for smoothness)
interp_result <- interp(
x = grid$x,
y = grid$y,
z = z,
xo = seq(0, 1, length = 100),
yo = seq(0, 1, length = 100),
linear = FALSE
)
# Static 3D plot
persp3D(
x = interp_result$x,
y = interp_result$y,
z = interp_result$z,
colvar = interp_result$z,
col = viridis::viridis(100),
theta = 40, phi = 30,
expand = 0.5,
shade = 0.8,
border = NA,
xlab = "X", ylab = "Y", zlab = "Z",
main = "Smooth Gaussian Random Field"
)
# Static 3D plot
persp3D(
x = interp_result$x,
y = interp_result$y,
z = interp_result$z,
# colvar = interp_result$z,
col = viridis::viridis(100),
theta = 40, phi = 30,
expand = 0.5,
shade = 0.8,
border = NA,
xlab = "X", ylab = "Y", zlab = "Z",
main = "Smooth Gaussian Random Field"
)
# Static 3D plot
persp3D(
x = interp_result$x,
y = interp_result$y,
z = interp_result$z,
# colvar = interp_result$z,
col = viridis::viridis(100),
theta = 40, phi = 30,
expand = 0.5,
shade = 0.8,
border = NA,
xlab = "X", ylab = "Y", zlab = "Z",
colkey = FALSE,      # <- Hides the Z-axis legend
main = "Smooth Gaussian Random Field"
)
# Static 3D plot
persp3D(
x = interp_result$x,
y = interp_result$y,
z = interp_result$z,
# colvar = interp_result$z,
col = viridis::viridis(200),
theta = 40, phi = 30,
expand = 0.5,
shade = 0.8,
border = NA,
xlab = "X", ylab = "Y", zlab = "Z",
colkey = FALSE,      # <- Hides the Z-axis legend
main = "Smooth Gaussian Random Field"
)
# Static 3D plot
persp3D(
x = interp_result$x,
y = interp_result$y,
z = interp_result$z,
# colvar = interp_result$z,
col = viridis::viridis(200),
theta = 40, phi = 30,
expand = 0.5,
shade = 0.8,
border = NA,
xlab = "s1", ylab = "s2", zlab = "z",
colkey = FALSE,      # <- Hides the Z-axis legend
main = "Smooth Gaussian Random Field"
)
# Static 3D plot
persp3D(
x = interp_result$x,
y = interp_result$y,
z = interp_result$z,
# colvar = interp_result$z,
col = viridis::viridis(200),
theta = 40, phi = 30,
expand = 0.5,
shade = 0.8,
border = NA,
xlab = "s[1]", ylab = "s[2]", zlab = "z",
colkey = FALSE,      # <- Hides the Z-axis legend
main = "Smooth Gaussian Random Field"
)
xlab = expression(s[1]),
persp3D(
x = interp_result$x,
y = interp_result$y,
z = interp_result$z,
colvar = interp_result$z,
col = viridis::viridis(100),
theta = 40, phi = 30,
expand = 0.5,
shade = 0.8,
border = NA,
colkey = FALSE,
xlab = expression(s[1]),
ylab = expression(s[2]),
zlab = "z",
main = "Smooth Gaussian Random Field"
)
# First, plot without axis labels
persp3D(
x = interp_result$x,
y = interp_result$y,
z = interp_result$z,
colvar = interp_result$z,
col = viridis::viridis(100),
theta = 40, phi = 30,
expand = 0.5,
shade = 0.8,
border = NA,
colkey = FALSE,
xlab = "", ylab = "", zlab = "",
main = "Smooth Gaussian Random Field"
)
# Then manually add plotmath labels
title(
xlab = expression(x[1]),
ylab = expression(x[2]),
zlab = "Z"
)
traceback()
quarto::quarto_preview()
# Parameters
theta <- seq(0, 1, length.out = 1000)  # Probability grid
# Prior: Beta(2, 2) — mildly informative
prior <- dbeta(theta, 2, 2)
# Likelihood: Binomial(10, 0.6) observed → 6 successes in 10 trials
# The likelihood is proportional to θ^6 * (1-θ)^4
likelihood <- dbeta(theta, 6 + 1, 4 + 1)  # Not scaled, for plotting
# Posterior: Beta(2+6, 2+4) = Beta(8, 6)
posterior <- dbeta(theta, 8, 6)
# Combine into data frame
df <- data.frame(
theta = theta,
Prior = prior,
Likelihood = likelihood,
Posterior = posterior
)
# Reshape for ggplot
library(tidyr)
df_long <- pivot_longer(df, cols = -theta, names_to = "Distribution", values_to = "Density")
# Plot
ggplot(df_long, aes(x = theta, y = Density, color = Distribution)) +
geom_line(size = 1) +
theme_minimal() +
labs(
title = "Bayesian Inference: Prior, Likelihood, and Posterior",
x = expression(theta),
y = "Density"
) +
scale_color_manual(values = c("Prior" = "blue", "Likelihood" = "orange", "Posterior" = "darkgreen"))
library(ggplot2)
# Parameters
theta <- seq(0, 1, length.out = 1000)  # Probability grid
# Prior: Beta(2, 2) — mildly informative
prior <- dbeta(theta, 2, 2)
# Likelihood: Binomial(10, 0.6) observed → 6 successes in 10 trials
# The likelihood is proportional to θ^6 * (1-θ)^4
likelihood <- dbeta(theta, 6 + 1, 4 + 1)  # Not scaled, for plotting
# Posterior: Beta(2+6, 2+4) = Beta(8, 6)
posterior <- dbeta(theta, 8, 6)
# Combine into data frame
df <- data.frame(
theta = theta,
Prior = prior,
Likelihood = likelihood,
Posterior = posterior
)
# Reshape for ggplot
library(tidyr)
df_long <- pivot_longer(df, cols = -theta, names_to = "Distribution", values_to = "Density")
# Plot
ggplot(df_long, aes(x = theta, y = Density, color = Distribution)) +
geom_line(size = 1) +
theme_minimal() +
labs(
title = "Bayesian Inference: Prior, Likelihood, and Posterior",
x = expression(theta),
y = "Density"
) +
scale_color_manual(values = c("Prior" = "blue", "Likelihood" = "orange", "Posterior" = "darkgreen"))
# Load libraries
library(spBayes)
install.packages("spBayes")
# Load libraries
library(spBayes)
library(fields)
library(viridis)
set.seed(123)
# Create spatial locations
n <- 100
coords <- cbind(runif(n, 0, 10), runif(n, 0, 10))  # 2D coordinates
# Simulate covariate and spatial field
x <- rnorm(n)
true_beta <- 1.5
sigma_sq_true <- 1     # spatial variance
tau_sq_true <- 0.1     # nugget effect
phi_true <- 0.5        # spatial decay
# Covariance matrix from exponential spatial decay
d <- rdist(coords)
Sigma <- sigma_sq_true * exp(-phi_true * d) + diag(tau_sq_true, n)
# Simulate spatial outcome
y <- true_beta * x + t(chol(Sigma)) %*% rnorm(n)
# Fit Bayesian spatial linear model
mcmc.samples <- spLM(
y ~ x, coords = coords,
starting = list("beta" = rep(0, 2), "phi" = 0.5, "sigma.sq" = 1, "tau.sq" = 0.1),
tuning = list("beta" = rep(0.01, 2), "phi" = 0.01, "sigma.sq" = 0.01, "tau.sq" = 0.01),
priors = list(
"beta.Norm" = list(0, 1e6),
"phi.Unif" = c(0.01, 1),
"sigma.sq.IG" = c(2, 1),
"tau.sq.IG" = c(2, 1)
),
n.samples = 2000,
cov.model = "exponential"
)
# Simulate spatial outcome
y <- true_beta * x + t(chol(Sigma)) %*% rnorm(n)
# Fit Bayesian spatial linear model
mcmc.samples <- spLM(
y ~ x, coords = coords,
starting = list("beta" = rep(0, 2), "phi" = 0.5, "sigma.sq" = 1, "tau.sq" = 0.1),
tuning = list("beta" = rep(0.01, 2), "phi" = 0.01, "sigma.sq" = 0.01, "tau.sq" = 0.01),
priors = list(
"beta.Norm" = list(0, 1e6),
"phi.Unif" = c(0.01, 1),
"sigma.sq.IG" = c(2, 1),
"tau.sq.IG" = c(2, 1)
),
n.samples = 2000,
cov.model = "exponential"
)
# Covariance matrix from exponential spatial decay
d <- rdist(coords)
Sigma <- sigma_sq_true * exp(-phi_true * d) + diag(tau_sq_true, n)
# Simulate spatial outcome
y <- true_beta * x + t(chol(Sigma)) %*% rnorm(n)
# Fit Bayesian spatial linear model
mcmc.samples <- spLM(
y ~ x, coords = coords,
starting = list("beta" = rep(0, 2), "phi" = 0.5, "sigma.sq" = 1, "tau.sq" = 0.1),
tuning = list("beta" = rep(0.01, 2), "phi" = 0.01, "sigma.sq" = 0.01, "tau.sq" = 0.01),
priors = list(
"beta.Norm" = list(0, 1e6),
"phi.Unif" = c(0.01, 1),
"sigma.sq.IG" = c(2, 1),
"tau.sq.IG" = c(2, 1)
),
n.samples = 2000,
cov.model = "exponential"
)
install.packages("spTimer")
install.packages('spTimer', repos = c('https://ksbakar.r-universe.dev', 'https://cloud.r-project.org'))
library(brms)
library(mgcv)
set.seed(123)
# ---------------------
# Simulate spatial and temporal data
# ---------------------
n_loc <- 30     # number of spatial locations
n_time <- 10    # number of time points
# Spatial coordinates
locations <- data.frame(
lon = runif(n_loc, 0, 10),
lat = runif(n_loc, 0, 10)
)
# Time variable (discrete for simplicity)
time_points <- 1:n_time
# Full spatio-temporal data frame
data_list <- list()
for (t in time_points) {
df <- data.frame(
lon = locations$lon,
lat = locations$lat,
time = t
)
data_list[[t]] <- df
}
data <- do.call(rbind, data_list)
# Add spatial smooth signal
data$spatial_effect <- with(data, sin(lon / 2) + cos(lat / 3))
# Add temporal smooth signal
data$temporal_effect <- sin(data$time / 2)
# Add covariate and noise
data$x1 <- rnorm(nrow(data))
data$y <- 1 + 0.5 * data$x1 + data$spatial_effect + data$temporal_effect + rnorm(nrow(data), 0, 0.3)
# Fit Bayesian GP in space and smooth in time
# NOTE: 'gp()' is Gaussian Process, 's()' is smooth spline
fit <- brm(
y ~ x1 + gp(lon, lat, k = 10, c = 1) + s(time, k = 5),
data = data,
chains = 2, iter = 2000, warmup = 1000,
cores = 2, seed = 123,
control = list(adapt_delta = 0.9)
)
# Predict at a fixed time (e.g. time = 5)
pred_data <- data[data$time == 5, ]
pred <- fitted(fit, newdata = pred_data)
# Plot
ggplot(pred_data, aes(x = lon, y = lat)) +
geom_point(aes(color = pred), size = 3) +
scale_color_viridis_c() +
labs(title = "Posterior Mean at Time = 5", color = "Predicted y") +
theme_minimal()
# Predict at a fixed time (e.g. time = 5)
# Get predicted values and add them to the data frame
pred_matrix <- fitted(fit, newdata = pred_data)
pred_data$predicted <- pred_matrix[, "Estimate"]
# Plot predicted values at time = 5
ggplot(pred_data, aes(x = lon, y = lat)) +
geom_point(aes(color = predicted), size = 3) +
scale_color_viridis_c() +
labs(title = "Posterior Mean at Time = 5", color = "Predicted y") +
theme_minimal()
